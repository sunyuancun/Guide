文档地址

    https://snailclimb.top/JavaGuide/#/


1. 面向对象和面向过程的区别  

    面向过程 ：面向过程性能比面向对象高。  因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。
    面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。
    
    总结： 因为面向对象 (不是直接编译成CPU执行的机械码)  类需要实例化，内存开销大，耗费资源，性能面向过程比面向对象好，但是面向对象有封装/继承/多态等特性，可以降低耦合度，更加灵活，容易维护，复用，扩展

2. Java程序编译和运行的过程

    1、源文件由编译器编译成字节码（ByteCode）    .java ----> .class (字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用（方法引用，成员变量引用等等）；方法字节码放的是类中各个方法的字节码。)

            javac  xx.java  编译  xx.class    
            javap -v  查看字节码   

    2、字节码由java虚拟机解释运行

        java类运行的过程大概可分为两个过程：1、类的加载  2、类的执行。
        JVM主要在程序第一次主动使用类的时候，才会去加载该类。  用的时候才加载，只加载一次。
        运行步骤： java xx.class 
        
        1. 系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，
        2. 然后JVM找到AppMain的主函数入口，开始执行main函数。

    java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言

3. Java语言有哪些特点
        1. 面向对象 /封装，继承，多态/
        2. 安全性 可靠性
        3. 支持多线程
        4. 支持网络编程
        5. 编译与解释并存
        6. 平台无关性（ Java 虚拟机实现平台无关性）；

4. 关于 JVM JDK 和 JRE 最详细通俗的解答

    JVM

    Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS）,目的是使用相同的字节码，它们都会给出相同的结果。
    ，目的是使用相同的字节码.
    字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。
    在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机

    JDK和JRE
    JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。
    JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。


5.  Java和C++的区别?

    1. 都是面向对象的语言，都支持封装、继承和多态
    2. Java 不提供指针来直接访问内存，程序内存更加安全
    3. Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
    4. Java 有自动内存管理机制，不需要程序员手动释放无用内存

6. 字符型常量和字符串常量的区别?
    形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符
    含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)
    占内存大小 字符常量只占2个字节; 字符串常量占若干个字节(至少一个字符结束标志) (注意： char在Java中占两个字节)

7. 构造器 Constructor 是否可被 override（重写）?

    在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，
    所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

8.  重载(overload（重载）)和重写(override（重写）)的区别   

    重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　
    重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；
    如果父类方法访问修饰符为 private 则子类就不能重写该方法

9. Java 面向对象编程三大特性: 封装 继承 多态

    封装
    封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性和方法，（常见的实现方式就是：getter、setter。）
    如果属性不想被外界访问，我们大可不必提供方法给外界访问。
    封装遵循了“开闭原则”，禁止外部直接访问和修改类的信息。

    继承（区别组合  继承是is关系，组合是has关系。）
    继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。
     要点：

     1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
     2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
     3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

    1. 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。
    2. 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override

     多态

        指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。
        实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。

        多态存在的三个必要条件 一、要有继承； 二、要有重写； 三、父类引用指向子类对象。
        Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。（java例子）
        Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

       可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。

        所有的class最终都继承自Object，而Object定义了几个重要的方法：

            toString()：把instance输出为String；
            equals()：判断两个instance是否逻辑相等；
            hashCode()：计算一个instance的哈希值。
            在必要的情况下，我们可以覆写Object的这几个方法。


    

10. 类变量、成员变量和局部变量

    类变量(静态变量)：用static修饰的变量称为静态变量，其内容被该类的所有对象共享，所有对象中这个类变量的值都指向相同的一处内存，随便一个对象修改了此处内存的值都会影响其他对象。
    成员变量：在类定义时声明的变量，随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。
    局部变量：在函数中声明的变量，只定义在局部范围内，只在所属的区域有效。存在于栈内存中，作用的范围结束，栈帧释放，变量就消失。

11. 构造函数与默认构造函数

    构造函数是用来初始化对象的，一个类可以重载多个构造函数。
    需要注意的是：默认情况下,一个类会有一个默认的构造函数,这个构造函数没有内容也没有返回值,一般都略去不写。
    但是,如果一个类定义了一个有参数有方法体的构造函数,这时编译器就不会再给它默认加上一个无参且方法体为空的构造函数，可以理解为无参的构造函数被覆盖，此时需要手动定义一个无参构造函数。
    在函数的继承里,子类必须使用super来实现对父类的非默认构造函数的调用.在创建对象时，先调用父类默认构造函数，然后调用子类自身自己定义的构造函数。

12. 继承（extends）和实现（implements）的区别
    概念不同
         继承：子类与父类的继承。如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。
         实现：接口的实现。如果多个类都有一个行为，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让各个类分别实现这个接口，各自实现自己具体的处理方法。
    数量不同
         单继承，多实现。
    格式不同
        在接口中只能定义全局常量（static final）,和空的方法体；而在继承中可以定义属性方法,变量,常量等...
    用法不同
        某个接口被类实现时,在类中一定要实现接口中的抽象方法；而继承则无需。


13. 接口和抽象类的区别是什么？
    1. 口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
    2. 接口中除了static、final变量，不能有其他变量，而抽象类中则没有限制。
    3. 一个类可以实现多个接口，但只能继承一个抽象类


14. final修饰符有多种作用

    final修饰的方法可以阻止被覆写；
    final修饰的class可以阻止被继承；
    final修饰的field必须在创建对象时初始化，随后不可修改。
        

15. 自动装箱与拆箱

    装箱：将基本类型用它们对应的引用类型包装起来；
    拆箱：将包装类型转换为基本数据类型；


16. String、StringBuffer和StringBuilder的区别

    1.  可变性与不可变性
       String 是不可变的 因为String 类中使用 final 关键字修饰字符数组来保存字符串。final　char　value[]
       StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，
    
    2. 线程安全性
        String 中的对象是不可变的，也就可以理解为常量，线程安全。
        AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。
        StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。　
    
    3. 性能
        每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

    三者使用的总结：
    操作少量的数据: 适用String
    单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder
    多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer


17. 创建一个对象用什么运算符?对象实体与对象引用有何不同?
    new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。
    一个对象引用可以指向0个或1个对象，一个对象可以有n个引用指向它

18. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?
    要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

19. 构造方法有哪些特性？
    1. 名字与类名相同。
    2. 没有返回值，但不能用void声明构造函数。
    3. 生成类的对象时自动执行，无需调用。

20. 静态方法和实例方法有何不同
    1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
    2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。

21. 对象的相等与指向他们的引用相等,两者有什么不同?
    对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

22. == 与 equals(重要)

    == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。
    
    equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
    情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
    情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

23. hashCode 与 equals (重要)

    1. hashCode（）介绍
        hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。
        “HashSet 如何检查重复原理：
             当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，
             如果没有相符的hashcode，HashSet会假设对象没有重复出现。
             但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。















